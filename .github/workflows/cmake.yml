name: CMake Build Matrix

on:
  push:
    branches: [ master ]
  schedule:
    - cron: '0 9 * * 1'
  workflow_dispatch:
  pull_request:
    branches: [ master ]
  pull_request_target:
    branches: [ master ]
    types: [ labeled, opened, reopened, synchronize ]
  merge_group:
    types: [ checks_requested ]

env:
  NINJA_VERSION: 1.10.1
  BUILD_TYPE: Release
  CCACHE_VERSION: 4.2.1
  MINGW_GCC_VERSION: 15.2.0
  MINGW_W64_VERSION: 13.0.0
  MINGW_REV: r1
  MINGW_ARCH: x86_64
  MINGW_THREAD: posix
  MINGW_EXCEPT: seh
  MINGW_CRT: ucrt

jobs:
  build:
    name: ${{ matrix.config.name }}
    if: >-
      ${{
        github.repository == 'savushkin-r-d/ptusa_main' && 
          (
          github.event_name == 'push' ||
          github.event_name == 'schedule' ||
          github.event_name == 'merge_group' ||
          github.event_name == 'workflow_dispatch' || 
            (
            github.event_name == 'pull_request_target' &&
            github.event.pull_request.head.repo.full_name != github.repository && 
              (
              contains(github.event.pull_request.labels.*.name, 'safe to test') ||
              github.event.pull_request.author_association == 'MEMBER' ||
              github.event.pull_request.author_association == 'OWNER'
              )
            ) || 
              (
              github.event_name == 'pull_request' &&
              github.event.pull_request.head.repo.full_name == github.repository
              )
          )
      }}
    runs-on: ${{ matrix.config.os }}
    strategy:
      fail-fast: false
      matrix:
        config:
        - {
            name: "Windows Latest MSVC",
            artifact: "Windows-MSVC.7z",
            os: windows-latest,
            cc: "cl",
            cxx: "cl",
            environment_script: "C:/Program Files/Microsoft Visual Studio/2022/Enterprise/VC/Auxiliary/Build/vcvars32.bat",
            targets: "ptusa_main libptusa_main main_test main_perfomance_test",
            run_tests: "true"
          }
        - {
            name: "Windows Latest MinGW",
            artifact: "Windows-MinGW.7z",
            os: windows-latest,
            cc: "gcc",
            cxx: "g++",
            targets: "ptusa_main libptusa_main",
            run_tests: "false"
          }
        - {
            name: "Ubuntu Latest GCC",
            artifact: "Linux.7z",
            os: ubuntu-latest,
            cc: "gcc",
            cxx: "g++",
            targets: "ptusa_main libptusa_main main_test main_perfomance_test",
            run_tests: "true"
          }
    steps:
    - name: Harden the runner (Audit all outbound calls)
      uses: step-security/harden-runner@df199fb7be9f65074067a9eb93f12bb4c5547cf2 # v2.13.3
      with:
        egress-policy: audit

    - uses: actions/checkout@1af3b93b6815bc44a9784bd300feb67ff0d1eeb3 # v6.0.0
      with:
        ref: ${{ github.event.pull_request.head.sha }}
        # Whether to checkout submodules: `true` to checkout submodules or `recursive` to
        # recursively checkout submodules.
        #
        # When the `ssh-key` input is not provided, SSH URLs beginning with
        # `git@github.com:` are converted to HTTPS.
        #
        # Default: false
        submodules: 'recursive'

    - name: Download Ninja and CMake
      shell: cmake -P {0}
      run: |
        set(cmake_version ${CMAKE_VERSION})
        set(ninja_version $ENV{NINJA_VERSION})
        message(STATUS "Using host CMake version: ${CMAKE_VERSION}")
        if ("${{ runner.os }}" STREQUAL "Windows")
          set(ninja_suffix "win.zip")
          set(cmake_dir "cmake-${cmake_version}-win64-x64/bin")
        elseif ("${{ runner.os }}" STREQUAL "Linux")
          set(ninja_suffix "linux.zip")
          set(cmake_dir "cmake-${cmake_version}-Linux-x86_64/bin")
        elseif ("${{ runner.os }}" STREQUAL "macOS")
          set(ninja_suffix "mac.zip")
          set(cmake_dir "cmake-${cmake_version}-Darwin-x86_64/CMake.app/Contents/bin")
        endif()
        set(ninja_url "https://github.com/ninja-build/ninja/releases/download/v${ninja_version}/ninja-${ninja_suffix}")
        file(DOWNLOAD "${ninja_url}" ./ninja.zip SHOW_PROGRESS)
        execute_process(COMMAND ${CMAKE_COMMAND} -E tar xvf ./ninja.zip)

        # Add to PATH environment variable
        file(TO_CMAKE_PATH "$ENV{GITHUB_WORKSPACE}/${cmake_dir}" cmake_dir)
        set(path_separator ":")
        if ("${{ runner.os }}" STREQUAL "Windows")
          set(path_separator ";")
        endif()
        file(APPEND "$ENV{GITHUB_PATH}" "$ENV{GITHUB_WORKSPACE}${path_separator}${cmake_dir}")
        if (NOT "${{ runner.os }}" STREQUAL "Windows")
          execute_process(
            COMMAND chmod +x ninja
          )
        endif()

    - name: Download ccache
      id: ccache
      shell: cmake -P {0}
      run: |
        set(ccache_url "https://github.com/cristianadam/ccache/releases/download/v$ENV{CCACHE_VERSION}/${{ runner.os }}.tar.xz")
        file(DOWNLOAD "${ccache_url}" ./ccache.tar.xz SHOW_PROGRESS)
        execute_process(COMMAND ${CMAKE_COMMAND} -E tar xvf ./ccache.tar.xz)

    - name: Prepare ccache timestamp
      id: ccache_cache_timestamp
      shell: cmake -P {0}
      run: |
        string(TIMESTAMP current_date "%Y-%m-%d-%H;%M;%S" UTC)
        file(APPEND "$ENV{GITHUB_OUTPUT}" "timestamp=${current_date}\n")

    - name: ccache cache files
      uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
      with:
        path: .ccache
        key: ${{ matrix.config.name }}-ccache-${{ steps.ccache_cache_timestamp.outputs.timestamp }}
        restore-keys: |
          ${{ matrix.config.name }}-ccache-

    - name: Disable man-db cache (Linux only)
      if: runner.os == 'Linux'
      run: echo 'man-db man-db/auto-update boolean false' | sudo debconf-set-selections && sudo dpkg-reconfigure man-db

    - name: Install yasm
      shell: cmake -P {0}
      run: |
        if ("${{ runner.os }}" STREQUAL "Windows")
          set(yasm_url "https://www.tortall.net/projects/yasm/releases/yasm-1.2.0-win64.exe")
          set(yasm_install_path "C:/Program Files/yasm")
          file(DOWNLOAD "${yasm_url}" "${yasm_install_path}/yasm.exe" SHOW_PROGRESS)
          # Add to PATH environment variable
          file(APPEND "$ENV{GITHUB_PATH}" ";${yasm_install_path}")

        elseif ("${{ runner.os }}" STREQUAL "Linux")
          execute_process(COMMAND sudo apt-get update)
          execute_process(COMMAND sudo apt-get install -y yasm)
        endif()

    - name: Install unixodbc-dev (Linux only)
      if: runner.os == 'Linux'
      run: sudo apt-get install -y unixodbc-dev

    - name: Cache MinGW archive
      if: runner.os == 'Windows' && matrix.config.name == 'Windows Latest MinGW'
      uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
      with:
        path: mingw_cache
        key: mingw-archive-${{ env.MINGW_GCC_VERSION }}-${{ env.MINGW_W64_VERSION }}-${{ env.MINGW_REV }}-${{ env.MINGW_THREAD }}-${{ env.MINGW_EXCEPT }}-${{ env.MINGW_CRT }}

    - name: Install MinGW-w64 (Windows MinGW only)
      if: runner.os == 'Windows' && matrix.config.name == 'Windows Latest MinGW'
      shell: cmake -P {0}
      run: |
        # Параметры версии вынесены в env (см. верх файла).
        set(gcc_ver $ENV{MINGW_GCC_VERSION})
        set(w64_ver $ENV{MINGW_W64_VERSION})
        set(rev     $ENV{MINGW_REV})
        set(arch    $ENV{MINGW_ARCH})
        set(thread  $ENV{MINGW_THREAD})
        set(excepts $ENV{MINGW_EXCEPT})
        set(crt     $ENV{MINGW_CRT})

        # Формирование имени релиза и архива.
        set(release_tag "${gcc_ver}${thread}-${w64_ver}-${crt}-${rev}")
        set(filename "winlibs-${arch}-${thread}-${excepts}-gcc-${gcc_ver}-mingw-w64${crt}-${w64_ver}-${rev}.zip")
        set(mingw_w64_url "https://github.com/brechtsanders/winlibs_mingw/releases/download/${release_tag}/${filename}")

        set(zip_dir "$ENV{GITHUB_WORKSPACE}/mingw_cache")
        file(MAKE_DIRECTORY "${zip_dir}")
        set(zip_path "${zip_dir}/mingw64.zip")

        if (EXISTS "${zip_path}")
          message(STATUS "Using cached MinGW archive: ${zip_path}")
        else()
          message(STATUS "Downloading MinGW-w64: ${mingw_w64_url}")
          file(DOWNLOAD "${mingw_w64_url}" "${zip_path}" SHOW_PROGRESS)
        endif()

        # Распаковываем напрямую в C:/ чтобы избежать промежуточного копирования.
        # В архиве корневая папка 'mingw64', поэтому после распаковки будет c:/mingw64.
        execute_process(
          COMMAND ${CMAKE_COMMAND} -E tar xf "${zip_path}"
          WORKING_DIRECTORY "c:/"
        )

        # Верификация.
        if (NOT EXISTS "c:/mingw64/bin/x86_64-w64-mingw32-gcc.exe")
          message(FATAL_ERROR "x86_64-w64-mingw32-gcc.exe not found after extraction.")
        endif()

        # Диагностика: показываем обнаруженные компиляторы в PATH и версию g++.
        message(STATUS "Diagnostics: locating 'g++' and 'x86_64-w64-mingw32-gcc' and printing g++ version.")
        execute_process(COMMAND where g++)
        execute_process(COMMAND where x86_64-w64-mingw32-gcc)
        execute_process(COMMAND g++ -v)


    - name: Configure
      shell: cmake -P {0}
      run: |
        set(ENV{CC} ${{ matrix.config.cc }})
        set(ENV{CXX} ${{ matrix.config.cxx }})
        if ("${{ runner.os }}" STREQUAL "Windows" AND NOT "x${{ matrix.config.environment_script }}" STREQUAL "x")
          execute_process(
            COMMAND "${{ matrix.config.environment_script }}" && set
            OUTPUT_FILE environment_script_output.txt
          )
          file(STRINGS environment_script_output.txt output_lines)
          foreach(line IN LISTS output_lines)
            if (line MATCHES "^([a-zA-Z0-9_-]+)=(.*)$")
              set(ENV{${CMAKE_MATCH_1}} "${CMAKE_MATCH_2}")
            endif()
          endforeach()
        endif()
        set(path_separator ":")
        if ("${{ runner.os }}" STREQUAL "Windows")
          set(path_separator ";")
        endif()
        set(ENV{PATH} "$ENV{GITHUB_WORKSPACE}${path_separator}$ENV{PATH}")

        if ("${{ runner.os }}" STREQUAL "Linux")
            set(ENV{CODE_COVERAGE} "ON")
        endif()

        execute_process(
          COMMAND cmake
            -S .
            -B build
            -D CMAKE_BUILD_TYPE=$ENV{BUILD_TYPE}
            -G Ninja
            -D CMAKE_MAKE_PROGRAM=ninja
            -D CMAKE_C_COMPILER_LAUNCHER=ccache
            -D CMAKE_CXX_COMPILER_LAUNCHER=ccache
            -D CODE_COVERAGE=$ENV{CODE_COVERAGE}
          RESULT_VARIABLE result
        )
        if (NOT result EQUAL 0)
          message(FATAL_ERROR "Bad exit status")
        endif()

    - name: Build
      shell: cmake -P {0}
      run: |
        set(ENV{NINJA_STATUS} "[%f/%t %o/sec] ")
        if ("${{ runner.os }}" STREQUAL "Windows" AND NOT "x${{ matrix.config.environment_script }}" STREQUAL "x")
          file(STRINGS environment_script_output.txt output_lines)
          foreach(line IN LISTS output_lines)
            if (line MATCHES "^([a-zA-Z0-9_-]+)=(.*)$")
              set(ENV{${CMAKE_MATCH_1}} "${CMAKE_MATCH_2}")
            endif()
          endforeach()
        endif()
        file(TO_CMAKE_PATH "$ENV{GITHUB_WORKSPACE}" ccache_basedir)
        set(ENV{CCACHE_BASEDIR} "${ccache_basedir}")
        set(ENV{CCACHE_DIR} "${ccache_basedir}/.ccache")
        set(ENV{CCACHE_COMPRESS} "true")
        set(ENV{CCACHE_COMPRESSLEVEL} "6")
        set(ENV{CCACHE_MAXSIZE} "400M")
        if ("${{ matrix.config.cxx }}" STREQUAL "cl")
          set(ENV{CCACHE_MAXSIZE} "600M")
        endif()
        execute_process(COMMAND ccache -p)
        execute_process(COMMAND ccache -z)
        execute_process(
          COMMAND cmake --build build --target ${{ matrix.config.targets }}
          RESULT_VARIABLE result
          OUTPUT_VARIABLE output
          ERROR_VARIABLE output
          ECHO_OUTPUT_VARIABLE ECHO_ERROR_VARIABLE
        )
        if (NOT result EQUAL 0)
          string(REGEX MATCH "FAILED:.*$" error_message "${output}")
          string(REPLACE "\n" "%0A" error_message "${error_message}")
          message("::error::${error_message}")
          message(FATAL_ERROR "Build failed")
        endif()
        execute_process(COMMAND ccache -s)

    # Install valgrind
    - name: Install valgrind on Linux
      if: runner.os == 'Linux'
      shell: bash
      run: |
        sudo apt-get update
        sudo apt-get install -y valgrind


    - name: Run tests
      if: matrix.config.run_tests == 'true'
      shell: cmake -P {0}
      run: |
        include(ProcessorCount)
        ProcessorCount(N)
        set(ENV{CTEST_OUTPUT_ON_FAILURE} "ON")

        if ("${{ runner.os }}" STREQUAL "Windows")
          execute_process(COMMAND luarocks path --lr-path
            RESULT_VARIABLE result_path
            OUTPUT_VARIABLE output_path
            OUTPUT_STRIP_TRAILING_WHITESPACE
          )
          execute_process(COMMAND luarocks path --lr-cpath
            RESULT_VARIABLE result_cpath
            OUTPUT_VARIABLE output_cpath
            OUTPUT_STRIP_TRAILING_WHITESPACE
          )
          if (result_path EQUAL 0 AND result_cpath EQUAL 0)
            set(ENV{LUA_PATH} "${output_path}")
            set(ENV{LUA_CPATH} "${output_cpath}")
          endif()

          message("LUA_PATH=\"$ENV{LUA_PATH}\"")
          message("LUA_CPATH=\"$ENV{LUA_CPATH}\"")
        endif()

        execute_process(
          COMMAND ctest -j ${N}
          WORKING_DIRECTORY build
          RESULT_VARIABLE result
          OUTPUT_VARIABLE output
          ERROR_VARIABLE output
          ECHO_OUTPUT_VARIABLE ECHO_ERROR_VARIABLE
        )
        if (NOT result EQUAL 0)
          string(REGEX MATCH "[0-9]+% tests.*[0-9.]+ sec.*$" test_results "${output}")
          string(REPLACE "\n" "%0A" test_results "${test_results}")
          message("::error::${test_results}")
          message(FATAL_ERROR "Running tests failed!")
        endif()

    - name: Install lcov (Linux only)
      if: runner.os == 'Linux'
      shell: bash
      run: |
        sudo apt-get update
        sudo apt-get install -y lcov

    - name: Create lcov report (Linux only)
      if: runner.os == 'Linux'
      shell: bash
      run: |
        lcov --capture --directory . --ignore-errors mismatch --output-file coverage.info
        lcov --remove coverage.info '/usr/*' --remove coverage.info '*/test/*' --remove coverage.info '*/googletest/*' --output-file coverage.info # filter system-files
        lcov --list coverage.info # debug info

    - name: Upload coverage to Codecov (Linux only)
      if: runner.os == 'Linux'
      uses: codecov/codecov-action@5a1091511ad55cbe89839c7260b706298ca349f7 # v5.5.1
      with:
        fail_ci_if_error: true
        verbose: true
        token: ${{ secrets.CODECOV_TOKEN }}

    - name: Store benchmark result (Linux only)
      if: runner.os == 'Linux'
      uses: benchmark-action/github-action-benchmark@4bdcce38c94cec68da58d012ac24b7b1155efe8b # v1.20.7
      with:
        name: C++ Benchmark
        tool: 'googlecpp'
        output-file-path: ./build/benchmark_result.json
        gh-repository: github.com/savushkin-r-d/benchmark-ptusa-main
        gh-pages-branch: main
        benchmark-data-dir-path: docs/dev/bench
        github-token: ${{ secrets.BENCHMARK_PTUSA_MAIN_TOKEN }}
        auto-push: true
        # Show alert with commit comment on detecting possible performance regression
        alert-threshold: '155%'
        comment-on-alert: true
        fail-on-alert: false
        alert-comment-cc-users: '@idzm'


    - name: Install Strip
      run: cmake --install build --prefix instdir --strip


    - name: Pack
      working-directory: instdir
      run: cmake -E tar cfv ../${{ matrix.config.artifact }} --format=7zip .


    - name: Upload
      uses: actions/upload-artifact@330a01c490aca151604b8cf639adc76d48f6c5d4 # v5.0.0
      with:
        path: ./${{ matrix.config.artifact }}
        name: ${{ matrix.config.artifact }}

  release:
    if: contains(github.ref, 'tags/v')
    runs-on: ubuntu-latest
    needs: build

    steps:
    - name: Harden the runner (Audit all outbound calls)
      uses: step-security/harden-runner@df199fb7be9f65074067a9eb93f12bb4c5547cf2 # v2.13.3
      with:
        egress-policy: audit

    - name: Create Release
      id: create_release
      uses: actions/create-release@0cb9c9b65d5d1901c1f53e5e66eaf4afd303e70e # v1.1.4
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ github.ref }}
        release_name: Release ${{ github.ref }}
        draft: false
        prerelease: false

    - name: Store Release url
      run: |
        echo "${{ steps.create_release.outputs.upload_url }}" > ./upload_url
    - uses: actions/upload-artifact@330a01c490aca151604b8cf639adc76d48f6c5d4 # v5.0.0
      with:
        path: ./upload_url
        name: upload_url

  publish:
    if: contains(github.ref, 'tags/v')
    name: ${{ matrix.config.name }}
    runs-on: ${{ matrix.config.os }}
    strategy:
      fail-fast: false
      matrix:
        config:
        - {
            name: "Windows Latest MSVC",
            artifact: "Windows-MSVC.7z",
            os: ubuntu-latest
          }
        - {
            name: "Windows Latest MinGW",
            artifact: "Windows-MinGW.7z",
            os: ubuntu-latest
          }
        - {
            name: "Ubuntu Latest GCC",
            artifact: "Linux.7z",
            os: ubuntu-latest
          }
    needs: release

    steps:
    - name: Harden the runner (Audit all outbound calls)
      uses: step-security/harden-runner@df199fb7be9f65074067a9eb93f12bb4c5547cf2 # v2.13.3
      with:
        egress-policy: audit

    - name: Download artifact
      uses: actions/download-artifact@018cc2cf5baa6db3ef3c5f8a56943fffe632ef53 # v6.0.0
      with:
        name: ${{ matrix.config.artifact }}
        path: ./

    - name: Download URL
      uses: actions/download-artifact@018cc2cf5baa6db3ef3c5f8a56943fffe632ef53 # v6.0.0
      with:
        name: upload_url
        path: ./
    - id: set_upload_url
      run: |
        upload_url=`cat ./upload_url`
        echo "upload_url=$upload_url" >> $GITHUB_OUTPUT
    - name: Upload to Release
      id: upload_to_release
      uses: actions/upload-release-asset@e8f9f06c4b078e705bd2ea027f0926603fc9b4d5 # v1.0.2
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ steps.set_upload_url.outputs.upload_url }}
        asset_path: ./${{ matrix.config.artifact }}
        asset_name: ${{ matrix.config.artifact }}
        asset_content_type: application/x-gtar
