# Датчик температуры Endress+Hauser TM311

> **Примечание:** Это техническая документация для разработчиков. Для инженеров АСУТП доступно [Руководство пользователя](TM311_user_guide.md) с описанием работы датчика на русском языке.

## Общее описание

**Класс:** `temperature_e_iolink_tm311`

**Тип устройства:** Датчик температуры IO-Link

**Производитель:** Endress+Hauser

**Артикул:** E&H.TM311

Датчик температуры TM311 представляет собой IO-Link устройство для измерения температуры. Класс `temperature_e_iolink_tm311` наследуется от базового класса `AI1` и реализует поддержку специфичных для этого датчика функций обработки данных и диагностики ошибок.

## Структура данных процесса

Датчик передает 4 байта процессных данных (Process Data In) со следующей структурой:

| Бит(ы) | Имя         | Тип    | Описание                                    |
|--------|-------------|--------|---------------------------------------------|
| 0      | OU1         | Bool   | Состояние выхода 1                          |
| 1-2    | Status2     | UInt2  | Дополнительный статус 2 (2 бита)            |
| 3-4    | Status1     | UInt2  | Основной статус (2 бита)                    |
| 5-7    | Unused      | -      | Неиспользуемые биты                         |
| 8-15   | Scale       | Int8   | Масштабный коэффициент                      |
| 16-31  | Temperature | Int16  | Значение температуры (с одним знаком после запятой) |

### Структура `TM311_data`

```cpp
struct TM311_data
{
    uint8_t OU1 : 1;       ///< Output 1 status bit.
    uint8_t status2 : 2;   ///< Extra status 2 bits.
    uint8_t status1 : 2;   ///< Status 2 bits.
    uint8_t unused : 3;    ///< Unused bits.
    int8_t scale{ -1 };    ///< Scale factor.
    int16_t temperature{}; ///< Temperature value (with one decimal place).
};
```

## Публичные методы

### `temperature_e_iolink_tm311(const char *dev_name)`

**Конструктор класса**

Инициализирует датчик температуры с указанным именем устройства.

**Параметры:**
- `dev_name` - имя устройства

### `float get_value()`

**Возвращает текущее значение температуры**

**Возвращаемое значение:**
- В режиме эмуляции: значение из базового класса `AI1`
- При ошибке связи IO-Link: аварийное значение из параметра `P_ERR`
- При нормальной работе: `P_ZERO_ADJUST_COEFF + 0.1 * info.temperature`

**Примечание:** Температура передается с одним знаком после запятой, поэтому умножается на 0.1

### `int get_state()`

**Возвращает состояние датчика**

**Возвращаемые значения:**

| Значение | Описание                                                          |
|----------|-------------------------------------------------------------------|
| 1        | Нормальное состояние (status1 == 3 && status2 == 0)              |
| 0        | Не используется в данной реализации                               |
| < 0      | Код ошибки (см. раздел "Коды ошибок состояния")                  |

#### Коды ошибок состояния

Отрицательные значения кодируются по формуле: `-10 - status1 * 10 - status2`

**Диапазоны ошибок:**

- **-10 до -19:** "Bad" - значение не может быть использовано
  - `-10`: Bad (status1=0, status2=0)
  - `-11`: Bad + Low limited (status1=0, status2=1)
  - `-12`: Bad + High limited (status1=0, status2=2)
  - `-13`: Bad + Constant (status1=0, status2=3)

- **-20 до -29:** "Uncertain" - значение может использоваться только ограниченно
  - `-20`: Uncertain (status1=1, status2=0)
  - `-21`: Uncertain + Low limited (status1=1, status2=1)
  - `-22`: Uncertain + High limited (status1=1, status2=2)
  - `-23`: Uncertain + Constant (status1=1, status2=3)

- **-30 до -39:** "Manual/Fixed" - значение может использоваться только ограниченно
  - `-30`: Manual/Fixed (status1=2, status2=0)
  - `-31`: Manual/Fixed + Low limited (status1=2, status2=1)
  - `-32`: Manual/Fixed + High limited (status1=2, status2=2)
  - `-33`: Manual/Fixed + Constant (status1=2, status2=3)

**Ошибки IO-Link:**
Если состояние IO-Link не равно `OK`, возвращается отрицательное значение состояния IO-Link.

### `void evaluate_io()`

**Обработка входных данных IO-Link**

Считывает 4 байта данных из канала IO-Link и заполняет структуру `TM311_data`. Выполняется переворачивание байтов для правильного порядка (endianness conversion).

**Алгоритм:**
1. Получение указателя на данные из канала AI
2. Копирование 4 байт в структуру `info`
3. Swap байтов 0 и 1
4. Swap байтов 2 и 3

### `const char* get_error_description()`

**Возвращает текстовое описание текущей ошибки**

Метод анализирует код ошибки (`get_error_id()`) и возвращает соответствующее описание на русском языке.

**Возвращаемые описания:**

#### Основные состояния (status1):

| Код ошибки | Основной статус | Описание                                                                                      |
|------------|-----------------|-----------------------------------------------------------------------------------------------|
| -10..-19   | Bad (0)         | 'Bad' - значение не может быть использовано                                                   |
| -20..-29   | Uncertain (1)   | 'Uncertain' — значение может использоваться только ограниченно (например, температура устройства вне диапазона) |
| -30..-39   | Manual/Fixed (2)| 'Manual/Fixed' — значение может использоваться только ограниченно (например, симуляция)       |

#### Дополнительные флаги (status2):

| Код ошибки (% 10) | Флаг             | Описание                                                                    |
|-------------------|------------------|-----------------------------------------------------------------------------|
| -1                | Low limited      | 'Low limited' - значение нарушило нижний предел                             |
| -2                | High limited     | 'High limited' - значение нарушило верхний предел                           |
| -3                | Constant         | 'Constant' - значение установлено как постоянное (например, симуляция)      |

**Примеры:**
- Код `-11`: "\'Bad\' - значение не может быть использовано; \'Low limited\' - значение нарушило нижний предел"
- Код `-22`: "\'Uncertain\' — значение может использоваться только ограниченно (например, температура устройства вне диапазона); \'High limited\' - значение нарушило верхний предел"
- Код `-33`: "\'Manual/Fixed\' — значение может использоваться только ограниченно (например, симуляция); \'Constant\' - значение установлено как постоянное (например, симуляция)"

**Примечание:** Если код ошибки выходит за пределы диапазона -39..-1, используется стандартное описание ошибки IO-Link из `iol_dev.get_error_description()`.

## Параметры устройства

### Константы

| Константа                | Значение | Описание                                   |
|--------------------------|----------|---------------------------------------------|
| P_ERR                    | 1        | Аварийное значение температуры              |
| ADDITIONAL_PARAM_COUNT   | 1        | Количество дополнительных параметров        |

## Примеры использования

### Чтение значения температуры

```cpp
temperature_e_iolink_tm311 sensor("TT101");
float temperature = sensor.get_value();

if (sensor.get_state() == 1) {
    // Значение корректно, можно использовать
    printf("Температура: %.1f °C\n", temperature);
} else {
    // Есть ошибка
    printf("Ошибка датчика: %s\n", sensor.get_error_description());
}
```

### Проверка состояния датчика

```cpp
temperature_e_iolink_tm311 sensor("TT101");
int state = sensor.get_state();

switch(state) {
    case 1:
        printf("Датчик работает нормально\n");
        break;
    case -11:
        printf("Значение не может быть использовано, нарушен нижний предел\n");
        break;
    case -22:
        printf("Значение неопределенное, нарушен верхний предел\n");
        break;
    default:
        printf("Ошибка датчика: %s\n", sensor.get_error_description());
}
```

## Тестирование

Для тестирования датчика используются unit-тесты в файле `test/device/PAC_dev_tests.cpp`.

### Пример теста

```cpp
// TM311 process data: 4 bytes.
TEST(IoLinkDevicesManager, temperature_e_iolink_tm311_test)
{
    ASSERT_EQ(create_device(TE, TE, "E&H.TM311"), 0);
    // Дополнительные проверки работы датчика
}
```

## Особенности реализации

1. **Byte swapping:** Данные от датчика передаются в определенном порядке байтов, который требует перестановки для корректной интерпретации.

2. **Масштабирование:** Температура передается как целое число, которое необходимо умножить на 0.1 для получения реального значения.

3. **Thread-local хранение:** Описание ошибки хранится в `thread_local` переменной для обеспечения потокобезопасности.

4. **Режим эмуляции:** При работе в режиме эмулятора используются значения из базового класса `AI1`.

5. **IO-Link диагностика:** Датчик поддерживает расширенную диагностику через интерфейс IO-Link, включая определение состояния связи и детальные коды ошибок.

## Связанные файлы

- **Заголовочный файл:** `PAC/common/device/device.h`
- **Реализация:** `PAC/common/device/device.cpp`
- **Тесты:** `test/device/PAC_dev_tests.cpp`

## Ссылки

- [Руководство пользователя для инженеров АСУТП](TM311_user_guide.md)
- [IO-Link спецификация](https://io-link.com/en/Technology/Technical.php)
- Документация Endress+Hauser TM311
- Базовый класс `AI1` для аналоговых входов
- Класс `io_link_device` для работы с IO-Link устройствами

## История изменений

- **2025-10-30:** Добавлена документация для функций обработки ошибок датчика TM311
