# Датчик температуры Endress+Hauser TM311

> **Примечание:** Это техническая документация для разработчиков. Для инженеров
АСУТП доступно [Руководство пользователя](TM311_user_guide.md) с описанием
работы датчика на русском языке.

## Общее описание

**Класс:** `temperature_e_iolink_tm311`

**Тип устройства:** Датчик температуры IO-Link

**Производитель:** Endress+Hauser

**Артикул:** E&H.TM311

Датчик температуры TM311 представляет собой IO-Link устройство для измерения
температуры. Класс `temperature_e_iolink_tm311` наследуется от базового класса
`AI1` и реализует поддержку специфичных для этого датчика функций обработки
данных и диагностики ошибок.

## Структура данных процесса

Датчик передает 4 байта процессных данных (Process Data In) со следующей
структурой:

| Бит(ы) | Имя         | Тип    | Описание                                    |
|--------|-------------|--------|---------------------------------------------|
| 0      | OU1         | Bool   | Состояние выхода 1                          |
| 1-2    | Status2     | UInt2  | Дополнительный статус 2 (2 бита)            |
| 3-4    | Status1     | UInt2  | Основной статус (2 бита)                    |
| 5-7    | Unused      | -      | Неиспользуемые биты                         |
| 8-15   | Scale       | Int8   | Масштабный коэффициент                      |
| 16-31  | Temperature | Int16  | Значение температуры (с одним знаком после запятой) |

### Структура `TM311_data`

```cpp
struct TM311_data
{
    uint8_t OU1 : 1;       ///< Output 1 status bit.
    uint8_t status2 : 2;   ///< Extra status 2 bits.
    uint8_t status1 : 2;   ///< Status 2 bits.
    uint8_t unused : 3;    ///< Unused bits.
    int8_t scale{ -1 };    ///< Scale factor.
    int16_t temperature{}; ///< Temperature value (with one decimal place).
};
```

## Публичные методы

### `temperature_e_iolink_tm311(const char *dev_name)`

#### Конструктор класса

Инициализирует датчик температуры с указанным именем устройства.

##### Параметры

- `dev_name` - имя устройства

### `float get_value()`

#### Возвращает текущее значение температуры

##### Возвращаемое значение

- В режиме эмуляции: значение из базового класса `AI1`
- При ошибке связи IO-Link: аварийное значение из параметра `P_ERR`
- При нормальной работе: `P_ZERO_ADJUST_COEFF + 0.1 * info.temperature`

**Примечание:** Температура передается с одним знаком после запятой, поэтому
умножается на 0.1.

### `int get_state()`

#### Возвращает состояние датчика

##### Возвращаемые значения

| Значение | Описание                                                          |
|----------|-------------------------------------------------------------------|
| 1        | Нормальное состояние (status1 == 3 && status2 == 0)              |
| 0        | Не используется в данной реализации                               |
| < 0      | Код ошибки (см. раздел "Коды ошибок состояния")                  |

#### Коды ошибок состояния

Отрицательные значения кодируются по формуле: `-10 - status1 * 10 - status2`.

##### Диапазоны ошибок

- **-10 до -19:** "Bad" - значение не может быть использовано
  - `-10`: Bad (status1=0, status2=0)
  - `-11`: Bad + Low limited (status1=0, status2=1)
  - `-12`: Bad + High limited (status1=0, status2=2)
  - `-13`: Bad + Constant (status1=0, status2=3)

- **-20 до -29:** "Uncertain" - значение может использоваться только
  ограниченно
  - `-20`: Uncertain (status1=1, status2=0)
  - `-21`: Uncertain + Low limited (status1=1, status2=1)
  - `-22`: Uncertain + High limited (status1=1, status2=2)
  - `-23`: Uncertain + Constant (status1=1, status2=3)

- **-30 до -39:** "Manual/Fixed" - значение может использоваться только
  ограниченно
  - `-30`: Manual/Fixed (status1=2, status2=0)
  - `-31`: Manual/Fixed + Low limited (status1=2, status2=1)
  - `-32`: Manual/Fixed + High limited (status1=2, status2=2)
  - `-33`: Manual/Fixed + Constant (status1=2, status2=3)

**Ошибки IO-Link:**
Если состояние IO-Link не равно `OK`, возвращается отрицательное значение
состояния IO-Link.

### `void evaluate_io()`

#### Обработка входных данных IO-Link

Считывает 4 байта данных из канала IO-Link и заполняет структуру `TM311_data`.
Выполняется переворачивание байтов для правильного порядка (endianness
conversion).

##### Алгоритм

1. Получение указателя на данные из канала AI
2. Копирование 4 байт в структуру `info`
3. Swap байтов 0 и 1
4. Swap байтов 2 и 3

### `const char* get_error_description()`

#### Возвращает текстовое описание текущей ошибки

Метод анализирует код ошибки (`get_error_id()`) и возвращает соответствующее
описание на русском языке.

##### Возвращаемые описания

#### Основные состояния (status1)

| Код ошибки | Основной статус | Описание                                                                                      |
|------------|-----------------|-----------------------------------------------------------------------------------------------|
| -10..-19   | Bad (0)         | 'Bad' - значение не может быть использовано                                                   |
| -20..-29   | Uncertain (1)   | 'Uncertain' — значение может использоваться только ограниченно (например, температура устройства вне диапазона) |
| -30..-39   | Manual/Fixed (2)| 'Manual/Fixed' — значение может использоваться только ограниченно (например, симуляция)       |

#### Дополнительные флаги (status2)

| Код ошибки (% 10) | Флаг             | Описание                                                                    |
|-------------------|------------------|-----------------------------------------------------------------------------|
| -1                | Low limited      | 'Low limited' - значение нарушило нижний предел                             |
| -2                | High limited     | 'High limited' - значение нарушило верхний предел                           |
| -3                | Constant         | 'Constant' - значение установлено как постоянное (например, симуляция)      |

##### Примеры

- Код `-11`: "\'Bad\' - значение не может быть использовано; \'Low
  limited\' - значение нарушило нижний предел".
- Код `-22`: "\'Uncertain\' — значение может использоваться только
  ограниченно (например, температура устройства вне диапазона); \'High
  limited\' - значение нарушило верхний предел".
- Код `-33`: "\'Manual/Fixed\' — значение может использоваться только
  ограниченно (например, симуляция); \'Constant\' - значение
  установлено как постоянное (например, симуляция)".

**Примечание:** Если код ошибки выходит за пределы диапазона -39..-1,
используется стандартное описание ошибки IO-Link из
`iol_dev.get_error_description()`.

## Параметры устройства

### Константы

| Константа                | Значение | Описание                                   |
|--------------------------|----------|---------------------------------------------|
| P_ERR                    | 1        | Аварийное значение температуры              |
| ADDITIONAL_PARAM_COUNT   | 1        | Количество дополнительных параметров        |

## Примеры использования

### Чтение значения температуры

```cpp
temperature_e_iolink_tm311 sensor("TT101");
float temperature = sensor.get_value();

if (sensor.get_state() == 1) {
    // Значение корректно, можно использовать
    printf("Температура: %.1f °C\n", temperature);
} else {
    // Есть ошибка
    printf("Ошибка датчика: %s\n", sensor.get_error_description());
}
```

### Проверка состояния датчика

```cpp
temperature_e_iolink_tm311 sensor("TT101");
int state = sensor.get_state();

switch(state) {
    case 1:
        printf("Датчик работает нормально\n");
        break;
    case -11:
        printf("Значение не может быть использовано, нарушен нижний предел\n");
        break;
    case -22:
        printf("Значение неопределенное, нарушен верхний предел\n");
        break;
    default:
        printf("Ошибка датчика: %s\n", sensor.get_error_description());
}
```

## Тестирование

Для тестирования датчика используются unit-тесты в файле
`test/device/PAC_dev_tests.cpp`.

### Пример теста

```cpp
// TM311 process data: 4 bytes.
TEST(IoLinkDevicesManager, temperature_e_iolink_tm311_test)
{
    ASSERT_EQ(create_device(TE, TE, "E&H.TM311"), 0);
    // Дополнительные проверки работы датчика
}
```

## Особенности реализации

1. **Byte swapping:** Данные от датчика передаются в определенном порядке

байтов, который требует перестановки для корректной интерпретации.

2. **Масштабирование:** Температура передается как целое число, которое

необходимо умножить на 0.1 для получения реального значения.

3. **Thread-local хранение:** Описание ошибки хранится в `thread_local`

переменной для обеспечения потокобезопасности.

4. **Режим эмуляции:** При работе в режиме эмулятора используются значения из

базового класса `AI1`.

5. **IO-Link диагностика:** Датчик поддерживает расширенную диагностику через

интерфейс IO-Link, включая определение состояния связи и детальные коды ошибок.

## Связанные файлы

- **Заголовочный файл:** `PAC/common/device/device.h`
- **Реализация:** `PAC/common/device/device.cpp`
- **Тесты:** `test/device/PAC_dev_tests.cpp`

## Ссылки

- [Руководство пользователя для инженеров АСУТП](TM311_user_guide.md)
- [IO-Link спецификация](https://io-link.com/en/Technology/Technical.php)
- Документация Endress+Hauser TM311
- Базовый класс `AI1` для аналоговых входов
- Класс `io_link_device` для работы с IO-Link устройствами

## История изменений

- **2025-10-30:** Добавлена документация для функций обработки ошибок датчика
  TM311.
