# Имитация датчика температуры #
Значения температуры в данной программе берутся из функции нормального распределения.

## Нормальное распределение ##
Нормальное распределение $-$ непрерывное распределение вероятностей с пиком в центре и симметричными боковыми сторонами, которое в одномерном случае задаётся функцией плотности вероятности, совпадающей с функцией Гаусса:

$$ f(x)= {1 \over (σ√2π)} e^{-{1\over 2}{\left(x-μ\over σ \right)}^2}$$

где ${μ}$ $-$ математическое ожидание, $σ$ $-$ cреднеквадратичное отклонение, $σ^2$ $-$ дисперсия распределения.

Математическое ожидание $-$ среднее значение случайной величины, в результате многократного повторения.

$$ μ ={\sum x \over n}$$

Например значения комнатной температуры могут находится примерно в интервале от 26 °C до 30°C. Если в течение всего дня фиксировать все изменения температуры в кабинете, то скорее всего мы увидим что-то на подобии [27.4, 26.9, 28.2, 29.1]. Математическим ожиданием или средним значением для такого интервала значений будет 27.9 °C.

 ${μ}$ находится на пике графика. На оси $x$ находятся все значения температуры, ось $y$ показывает вероятность того, что наша случайная величина будет иметь заданную температуру.

<p align="center">
<img align="center" src="../../readme_images/m_expec.png"> </p>
<p align="center"> Математическое ожидание </p>

 Вероятность $p$ можно вычислить, посчитав площадь графика в конкретном интервале, площадь всего графика равна 1.

<p align="center">
<img align="center" src="../../readme_images/square.png"> </p>

Дисперсия $-$ расброс  значений случайной величины относительно мат. ожидания. Дисперсию можно вычислить по формуле ниже:

$$ D={\sum (x-\mu)^2 \over n}$$

Квадрат в формуле нужен на случай отрицательных значений. Возвращаюсь к нашему примеру, дисперсия будет равна 0.695. Сама по себе дисперсия не очень информативна, более четкое понимание насколько рассеяны значения дает стандартное отклонение:

$$ \sigma ={\sqrt D} $$

При $D$ = 0.695

$ \sigma ={\sqrt {0.695} \approx 0.833667} $ °C


<p align="center">
<img align="center" src="../../readme_images/st_dev.png"> </p>
<p align="center"> Стандартное отклонение </p>

Т. е. чем больше $\sigma$, тем «шире» график.

## Реализация ##
Файлы с реализацией находятся в ```ptusa_main/Pac/common```. В классе analog_emulator определены функции расчета стандартного отклонения ```get_st_deviation()```, вероятности ```is_p()```. Дисперсия и мат. оиждание задаются в параметрах конструктора, также в конструктор можно передать первоначальное значение $x$ и минимальную с максимальной температуры.

```c++
bool analog_emulator::is_p() const
    {
    // f(x)=1/(σ√2π)∙e^(-1/2∙((x-μ)/σ)^2) - функция Гаусса
    // σ - стандартное отклонение
    // x - случайная величина
    // μ - математическое ожидание
    constexpr double two_pi = 2 * M_PI;
    return ( 1 / ( st_deviation * sqrt( two_pi ) ) ) *
        exp( -( pow( x - m_expec, 2 ) / ( 2 * st_deviation * st_deviation ) ) ) > 0.01;
    }   // 0.01 вероятность того, что случайная величина находится 
        // в заданном диапазоне температур
```    
Главная функция ```get_value()```, которая и возвращает некую температуру, присваиваивает $x$ случайное значение из заданного диапазона температур, а затем считает чему равна функция, т. е  вероятность в данной точке и больше ли она уже какого-то заданного ненулевого значения вероятности. Если условие истино, то ```get_value()``` возвращает $x$ и записывает его в статическую переменную, которая хранит предыдущие значения температуры, на случай если у следующего $x$ будет слишком маленькая вероятность, тогда ```get_value()``` просто вернет старое значение температуры.

```c++
float analog_emulator::get_value()
    {
    x = get_random();
    static float old_value;
    if ( is_p() )
        {
        old_value = x;
        return x;
        }
    else
        {
        return old_value;
        }
    }
```
