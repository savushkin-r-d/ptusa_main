# Стратэгія аўтаматызацыі ТЭСТАВАННЯ ПРАЕКТУ #

Дакумент змяшчае апісанне стратэгіі аўтаматызацыі тэсціравання праекта.

## Архітэктура праекта ##

Праект складаецца з наступных складнікаў:
1. IOT – модуль для працы з дадатковымі прыладамі.
2. OPCUAServer – модуль для сувязі з серверам выкарыстоўваючы спецыфікацыю OPC Unified Architecture.
3. G_LUA_MANAGER - модуль для працы c сістэмнымі і карыстальніцкімі скрыптамі напісанымі ў Lua.
4. G_PROFIBUS_SLAVE - модуль для працы з прамысловай сеткай PROFIBUS.
5. G_PROJECT_MANAGER - модуль, які адказвае за канфігурацыю праекта, а менавіта, апрацоўку ўваходных параметраў, загрузку канфігурацыі для G_LUA_MANAGER, усталёўку шляхоў да сістэмных і карыстальніцкіх файлаў Lua.
6. G_IO_MANAGER – чытанне і запіс станаў модуляў уводу/высновы
7. G_DEVICE_MANAGER - модуль змяшчае інфармацыю аб усіх прыладах праекта (клапанаў, рухавікоў, лічыльнікаў і г.д.)
8. G_TECH_OBJECT_MANAGER - модуль для кіравання тэхналагічнымі аб'ектамі (танк, грабянец і г.д.)
9. G_CMMCTR - tcp камунікатар
10. G_ERRORS_MANAGER - модуль апрацоўкі памылак сістэмы
11. G_SIREN_LIGTHS_MANAGER - модуль для працы са светлавой гукавой сірэнай (зялёнай, жоўтай і чырвонай лямпачкай, а таксама з гукавой сірэнай).
12. G_LOG - модуль які адказвае за лагіраванне

## Віды тэсціравання ##
Прапануецца 3 этапы тэставання ПЗ:
- unit тэсты
- тэсціраванне прадукцыйнасці
- тэсціраванне на этапе бесперапыннай інтэграцыі
- тэставанне ПЗ усярэдзіне сістэмы (пераводзячы ПЛК у тэставы рэжым на кароткі час).

### Unit тэсты ###
Пакрыццё класаў праекту unit тэстамі дазваляе паменшыць колькасць памылак,
якія выяўляюцца ў якая працуе сістэме, паменшыць час на інтэграцыю новых абнаўленняў,
павялічыць прадукцыйнасць сістэмы. Тэсціраванне праекта актыўна, абавязкова для новых змен.

### Тэставанне прадукцыйнасці ###

Вынікі тэстаў знаходзяцца тут - <https://savushkin-r-d.github.io/benchmark-ptusa-main/docs/dev/bench/>.

## Бесперапынная інтэграцыя ##
У працэс распрацоўкі вядзецца паўнавартасны аўтаматызаваны працэс бесперапыннай інтэграцыі (CI)
новага кода (мал. 1). Пасля кожнага зліцця невялікай скончанай функцыянальнасці з галінкі распакоўшчыка ў асноўную галінку запускаюцца аўтаматычныя тэсты:
- Regression tests - рэгрэсійныя тэсты
- Functional tests - тэсты новай функцыянальнасці
  Пасля чаго генеруецца рапарт у зручным для канчатковага карыстальніка выглядзе 
- (pdf, html, візуальныя графікі), які павінен змяшчаць як агульную інфармацыю тэсціравання, 
- так і канкрэтную інфармацыю пра памылкі (логі).
  Выкарыстоўваецца сістэма **Github Actions**.

Малюнак 1: Схема аўтаматызацыі бесперапыннай інтэграцыі новага кода

![Image alt](readme_images/pic1BY.png)

## Тэставанне кампанентаў ПЗ унутры сістэмы ##
Тэставанне ПЗ усярэдзіне сістэмы забяспечыць хуткае знаходжанне патэнцыйных і існых праблем
не звяртаючыся да ручнога тэставання з выкарыстаннем тэставага стала. Аўтаматычнае тэсціраванне
ўнутры сістэмы можна інтэграваць у працэс абнаўлення праграмнага забеспячэння. Аўтаматызацыя
тэсціравання ўнутры сістэмы не мае на ўвазе выкарыстання дадатковага абсталявання (мал. 2)

Малюнак 2: Схема мінімальнага абсталявання, неабходнага для тэсціравання ПЗ унутры сістэмы

![Image alt](readme_images/pic2BY.png)

Алгарытм тэсціравання ПЗ унутры сістэмы прадстаўлены на мал. 3.
Дадзены алгарытм рэалізуецца на серверы ў выглядзе кіравальнай праграмы або выконваючага скрыпту
на любой ЯП, або з выкарыстаннем любой прылады, які забяспечвае працэс бесперапыннай інтэграцыі
праграмнага забеспячэння, напрыклад Jenkins. Пры неабходнасці загрузкі новага ПЗ, адразу пасля 
апгрэйду, ПЛК пераводзіцца ў тэставы рэжым спецыяльнай камандай. Перавод ПЛК у тэставы рэжым 
азначае - рэканфігурацыю такім спосабам, каб модулі ПА ПЛК заставаліся ў працаздольным стане, 
але не аказвалі ніякага ўздзеяння на сістэму і прылады якімі дадзены ПЛК кіруе, або да якіх 
ПЛК падлучаны. Такі рэжым можа быць рэалізаваны з дапамогай уводу новых спецыяльных 
MOCK-аб'ектаў (аб'ектаў заглушак). Прыклад MOCK-аб'екта - неабходна будзе падрыхтаваць набор 
спецыяльных "пустых", г.зн. нічога не робяць, сістэмных і карыстальніцкіх Lua скрыптоў.

Малюнак 3: Алгарытм тэсціравання ПЗ унутры сістэмы

![Image alt](readme_images/pic3BY.png)

Далей сервер у цыкле высылае каманды для тэставання неабходных модуляў ПЗ,
збірае вынікі тэстаў і генерыруе справаздачу ў зручнай форме (pdf, html).
Аўтаматычнае тэсціраванне можа выконвацца, як і пры абнаўленні ПА, так 
і ў любы іншы момант часу (у дадзеным выпадку алгарытм намаляваны мал. 
3 не будзе ўключаць у сябе кроку загрузкі новай версіі праграмы ў ПЛК).

## Кампаненты і класы для тэсціравання ##
### Unit тэсты ###
Unit тэсты павінны пакрываць усе класы ПЗ і абавязкова запускацца перад зборкай новай версіі праграмы.
### Модулі ПЗ для тэставання ўнутры сістэмы ###
Для тэсціравання ўнутры сістэмы прапануецца мінімальны набор з наступных модуляў:
1. IOT модуль.
2. OPCUAServer модуль.
3. G_LUA_MANAGER модуль.
4. G_PROFIBUS_SLAVE модуль.
5. G_PROJECT_MANAGER модуль.
6. G_TECH_OBJECT_MANAGER модуль.
7. tcp камунікатар

Таксама пры неабходнасці можна пашырыць гэты спіс іншымі модулямі.

### Тэст для аднаго модуля ўнутры сістэмы ###
Тэст модуля ўнутры сістэмы ўяўляе сабой спецыяльны клас самадыягностыка. Падчас самадыягностыкі павінна правярацца:
- функцыянаванне модуля;
- унутраны стан модуля;
- статут падлучэння да іншых модуляў і/ці прыладам;
- сеткавы статус, калі модуль забяспечвае доступ да якой-небудзь сеткі.

Сабраная інфармацыя ў канцы самадыягностыкі павінна адпраўляцца на сервер.

### Інтэрфейс для аўтаматычнага тэсціравання ###
Інтэрфейс падлучэння ПЛК да сервера павінен быць дапоўнены наступнымі камандамі:
- перавод ПЛК у тэставы рэжым;
- перавод ПЛК у працоўны рэжым;
- каманда выканання самадыягностыкі модуля (адна каманда на модуль).
